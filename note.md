##  메모장

***

<br><br>

## :round_pushpin: Java

***

<br>

### :pushpin: Java란?

- 최초 가전제품에서 쓰일 용도로 개발된 프로그램 언어
- 한 번 쓰고 어느 곳에도 실행하는 것을 목표로 함
- **특징**
  - 객체지향 언어(OOP)
  - 높은 이식성
  - 컴파일 언어인 동시에 인터프리터 언어
    - 텍스트 소스 컴파일 -> 2진 파일(클래스 파일) -> 자바 런타임이 클래스 파일을 인터프리트 하면서 실행
  - 메모리 자동관리
    - 개발자가 직접 메모리에 접근 불가
    - 메모리를 자바가 관리
    - 객체 생성시 자동 메모리 영역 탐색 및 할당, 사용 완료 후 가비지 컬렉션을 실행시켜<br> 사용하지 않는 메모리 해제

<br>

### :pushpin: Garbage Collector(GC)

- Call Stack, Memory Heap의 자원은 한정적이기 때문에 이를 효율적으로 관리해주는 도구
- GC는 더 이상 효용가치가 없다고 판단되는 변수, 함수 등을 함수 실행 종료 후 Memory Heap에서 제거하는 동작을 수행한다.
- 표시하고 쓸기(Mark-and-Sweep) 알고리즘
  - 이 알고리즘은 roots라는 Object의 집합을 가지고 있는데, 주기적으로 Garbage Collector는<br> roots로부터 시작하여 roots가 참조할 수 있는 Object들을 닿을 수 있는 Object로 표시한다.
  - roots가 참조할 수 없는, 즉 닿을 수 없는 Object에 대해 Garbage Collection을 수행한다.

<br>

### :pushpin: 함수(Function) & 메소드(Method) 차이점

- **[함수]** : 특정 작업을 수행하는 코드 조각, 독립된 기능을 수행하는 단위

- **[메소드 = 클래스 함수]** : 클래스, 구조체, 열거형에 포함된 함수

  > **클래스 외부, 내부에 위치하는 차이**

<br> 

### :pushpin: 오버로딩(Overloading) & 오버라이딩(Overriding) 차이

- **오버로딩** : 메서드의 이름은 같지만, 매개변수의 데이터 타입과 개수가 다른 것
- **오버라이딩** : 상위 클래스가 가진 메서드를 하위 클래스가 재정의해서 사용

- **오버로딩 예시**

  ```c++
  class OverloadingClass{
      public : 
      void push(int x, int y){ }
      void push(string x, string y){ }
      void push(int x, int y, int z){ }
  }
  ```

- **오버라이딩 예시**

  ```c++
  class SuperClass{
      public :
      void push(int x, int y){ }
  }
  // 다형성 : 서로 다른 객체들 사이에서 같은 함수를 사용했을 때 다르게 동작하는 것
  class SubClass : SuperClass{
      public : 
      void push(int x, int y){ cout<<"SuperClass의 push() 메서드를 오버라이딩"; }
  }
  ```

<br> 

### :pushpin: 추상 클래스(Abstract Class) & 인터페이스(Interface) 

- **공통점**
  - 자신을 new를 통해 생성할 수 없으며, 상속받은 자식 클래스만이 객체를 생성 가능하다.
  - 하나의 클래스이며 자식 클래스에서 모든 메서드를 구현해야 한다.
  - 인스턴스화가 불가능하다.
- **차이점**
  - **추상 클래스(확장 관계)**
    - 부모 클래스가 가진 공통적인 기능들을 여러 클래스에서 사용할 경우에 사용
    - 다중 상속 불가, 하나의 클래스에 하나의 부모만 상속 가능(extends)
  - **인터페이스(포함 관계)**
    - 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용
    - 각 클래스가 서로 다른 부모 클래스를 상속하지만, 같은 기능이 필요한 경우에 사용
    - 다중 상속 가능, 하나의 클래스에 여러 인터페이스 상속 가능(implements)
    - 필요에 따라 결합

<br> 

### :pushpin: 업캐스팅(Upcasting) & 다운캐스팅(Downcasting)

> **캐스팅(Casting) : 타입을 변환하는 것**
>
> **ex) String to Integer, Integer to String**

- **업캐스팅 : 부모 클래스로 자식 클래스를 가르키는 것**
  - 여러 개의 자식 클래스가 하나의 부모 클래스를 상속받고 있을 때<br> (부모 클래스 = 자식 클래스 중에 하나)의 코드로 다중 if문과 같은 효과를 낼 수 있음
  - 업캐스팅 이후의 부모 클래스는 자식 클래스의 멤버 변수에 접근 불가
  - 업캐스팅 이후의 부모 클래스는 부모 클래스 자신의 멤버 함수만을 통해서 자식 클래스의<br> 멤버 함수에 접근 가능

- **다운캐스팅 : 자식 클래스로 부모 클래스를 가르키는 것**
  - 업캐스팅된 객체를 다시 원래의 상태로 되돌리는 것
  - 자식 클래스 = (자식 클래스 타입)부모 클래스
  - 업캐스팅된 객체는 부모 클래스 타입으로 지정되어 있기 때문에 해당 객체의<br> 고유성을 원할 때 다운캐스팅을 사용하는 것

<br> 

### :pushpin: 추상 클래스

> **여러 객체의 공통되는 속성이나 특성을 추출하여 하나로 만들어놓은 것**

- **추상 메서드** 
  - 특정 메서드를 추상 클래스에서 일반 클래스로 구현하게 되면<br> 상속받은 자식 클래스에서 구현하지 않는 경우가 발생하여 강제적으로 구현하게 <br> 할 수 있는 추상 메서드가 탄생
- **추상 클래스 장점**
  - 부모 클래스에서 공통 부분을 갖고 있기 때문에 자식 클래스에서 기능 확장시 편리하다.
  - 프로그램의 표준화 정도를 높인다.
  - 공통 부분이 한 곳에서 관리되어 개발 및 유지보수에 용이하다.

<br> 

### :pushpin: 인터페이스

> **다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의<br> 중간 매개 역할까지 담당하는 일종의 추상 클래스**

- 추상 메서드와 상수만을 포함
- implements를 통한 다중 상속 가능
- 개발 코드를 직접 수정하지 않고 사용 중인 객체만 변경할 수 있도록 한다(유지보수성)

<br> 

### :pushpin: 내부 클래스

> **클래스 내에 선언된 클래스다.**

- 두 클래스가 서로 긴밀한 관계에 있을 때 내부 클래스를 사용하여 구현한다.
- 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
- 코드의 복잡성을 줄일 수 있다.
- 일반 클래스에서 내부 클래스의 멤버에 접근 가능
- **종류**
  - **정적 클래스(static class)**
    - 내부 클래스 중 static 키워드를 가지는 클래스
    - 주로 외부 클래스의 메서드에 사용될 목적으로 선언
  - **인스턴스 클래스(instance class)**
    - 내부 클래스 중 static 키워드를 가지지 않는 클래스
    - 주로 외부 클래스의 인스턴스 변수나 메서드에 사용될 목적
  - **지역 클래스(local class)**
    - 외부 클래스의 메서드나 초기화 블록에 선언된 클래스
    - 선언된 블록 내에서만 사용할 수 있음
  - **익명 클래스(anonymous class)**
    - 내부 클래스와 달리 이름을 가지지 않는 클래스
    - 클래스 선언과 동시에 객체를 생성
    - 일회용 클래스
    - 생성자 선언 불가, 하나의 인터페이스만 상속받거나 구현 가능
    - 구현해야 하는 메서드가 매우 적은 클래스를 구현할 때 사용된다.

<br>

### :pushpin: 객체지향 프로그래밍(OOP: Object Oriented Programming)이란?

- 캡슐화, 추상화, 다형성, 상속
- **캡슐화**
  - 일반적으로 연관 있는 변수와 함수를 클래스로 묶는 작업
  - 대표적으로 getter, setter가 있다.
  - 정보 은닉을 위해 사용(중요한 데이터나 기능을 외부에서 접근하지 못하게 할 수 있다)
- **추상화**
  - 일반화 시키는 것
  - 자료, 모듈, 시스템 등에서 핵심적인 개념 또는 기능을 간추려내는 것
  - 하나의 모델을 만들어서 다른 확장 관계에 있는 클래스 설계를 시도할 때 효율적으로 하기 위함
- **다형성**
  - 여러 형태를 받아들일 수 있는 성질이나 상황에 따라 의미를 다르게 부여할 수 있는 특성
  - 오버로딩과 오버라이딩, 함수형 인터페이스를 통해 구현합니다.
    - 오버로딩 : 메서드의 이름은 같지만 인자의 개수나 데이터 타입이 다르게 구현하는 것
    - 오버라이딩 : 상속 받았을 때 상위 클래스의 메서드를 하위 클래스에서 재정하는 것
    - 함수형 인터페이스 : 람다식을 사용하기 위한 API입니다, 인터페이스에 구현할 메서드가 하나 뿐인 인터페이스를 말한다. 주로 열거형과 함께 사용한다.
- **상속**
  - 부모 클래스에서 정의된 필드와 메서드를 자식 클래스가 물려받는 것
  - 클래스 사이 공통된 특징을 가지고 있을 때 불필요한 멤버의 중복 선언을 방지
  - 멤버를 재사용함으로써 재사용성, 확장성, 가독성이 증가
  - 자바에서 최상위 클래스는 Object 클래스(Object 클래스만이 슈퍼클래스를 가지지 않는다)



<br>

### :pushpin: 접근 지정자(Public, Private, Default, Protected)

> **특정 패키지, 클래스에서 객체에 접근할 수 있는 범위를 지정해주는 것** 

- Public
  - 접근 제한 없음
  - 동일 클래스, 동일 패키지, 다른 패키지의 자식 클래스, 다른 패키지
- Protected
  - 동일 패키지와 상속 받은 클래스 내부에서만 허용
  - 동일 클래스, 동일 패키지, 다른 패키지의 자식 클래스 허용
- Private
  - 동일 클래스 내에서만 접근 가능
  - 동일 클래스 허용
- Default
  - 동일 패키지, 동일 클래스 내에서만 접근 가능

<br>

### :pushpin: 라이브러리(Library)

-  **정의**
  - 자주 사용하는 기능을 재가공해서 공통으로 사용될 수 있도록 모듈화한 것
  - 대상 환경(플랫폼)에서 바로 실행될 수 있는 형태로 제공



<br> 

### :pushpin: API(Application Programming Interface)란?

- **정의**
  - 응용 프로그램에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게<br> 만든 인터페이스

- **장점**
  - API를 사용하면 구현 방식을 알지 못해도 제품 또는 서비스가 서로 소통할 수 있다.
  - 애플리케이션 개발을 간소화하여 시간과 비용을 절약할 수 있다.

<br> 

***

<br>



## :round_pushpin: WEB

***

<br>

### :pushpin: JSON과 XML

- **JSON(JavaScript Object Notation)**

  - 데이터를 저장하고 전달할 때 사용되는 경량의 데이터 교환 형식
  - 데이터 포맷, 데이터를 표시하는 표현 방법 중 하나
  - **자바스크립트 객체의 형식**을 기반으로 만들어짐
  - 특정 언어에 종속되지 않는다.
  - 자바스크립트 자체도 전달할 수 있는데 Ajax와 같은 비동기 통신에서 악성 자바스크립트 코드를<br> 전달한다면 보안상에 문제가 생길 수 있다.

- **XML(Extensible Markup Language)**

  - HTML과 매우 비슷한 문자 기반의 **마크업 언어**
  - 데이터를 저장하고 전달하는 목적으로 만들어짐
  - XML 태그는 미리 정의되어 있지 않고 사용자가 직접 정의 가능하다.

- **차이점**

  - JSON 형식에서는 null, number, string, array, object, boolean을 사용 가능

  - JSON은 Key와 Value 형태로 표현, XML은 태그로 표현

    > **JSON : {"key" : "value"}**
    >
    > **XML : \<key>\<value>\</value>\</key>**

<br>

### :pushpin: AJAX(Asynchronous  Javascript And XML)  - 비동기식 자바스크립트와 XML

- **정의**
  - 자바스크립트를 이용해 서버와 브라우저가 **비동기 방식**으로 <br> 데이터를 교환할 수 있는 통신 기능을 가진 **자바스크립트의 라이브러리 중 하나**
  - 브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 페이지 일부만을 위한<br> 데이터를 로드하는 기법
  - 자바스크립트를 통해 서버에 데이터를 **비동기 방식**으로 요청하는 것
  - HTML, DOM, JavaScript, XMLHttpRequest, Etc 등의 기술과 혼합하여 사용된다.<br> 
- **비동기 방식**
  - 웹 페이지를 로드하지 않고 데이터를 불러오는 방식
  - 요청 후 결과 값을 반환받기 전까지 기다리지 않는다.
  - **장점**
    - 페이지 리로드의 경우 전체 리소스(이미지, 스크립트, 기타 코드)를 재요청해야 하지만<br> 비동기 방식을 사용하면 필요한 부분만 로드할 수 있기 때문에 리소스 낭비가 발생하지 않는다.
  - **단점**
    - 히스토리가 관리되지 않는다.
    - 페이지 이동없는 통신 특성상 보안에 문제가 존재한다.
    - 연속으로 데이터 요청시 서버 부하 증가 가능
    - HTTP 클라이언트의 기능이 한정되어 있다.

<br>

### :pushpin: JavaScript란?

- HTML, CSS는 정적 언어, 이를 통해 만들어진 웹 페이지를 동적으로 변경해주는 언어
- 객체 기반 언어지만, 상속과 클래스 개념은 없다.
- 인터프리터 언어로서 클라이언트의 웹 브라우저에 의해 해석되고 실행된다.
- 싱글 스레드 기반 언어
  - 호출 스택이 하나이기 때문에 한 번에 하나의 작업만 처리 가능
- **자바 스크립트 엔진**을 통해 실행됨
  - **Memory Heap**과 **Call Stack**을 가지고 있음
    - **Memory Heap** : 변수, 함수 등의 정보를 저장하는 공간
    - **Call Stack** : 실행 중인 코드를 트래킹
    - 변수, 함수를 Memory Heap에 동적으로 저장 해놓고 Call Stack에서 필요한 것들은 Memory Heap에서 찾아 수행한다.
  - **동작 방식**
    - 1. 엔진에서 자바스크립트 소스코드를 가져와 Parser에게 넘김
      2. Parser는 파싱을 통해 AST(Abstract Syntax Tree)로 변환시킨다.
      3. AST를 인터프리터를 통해 바이트 코드로 변환
      4. 바이트 코드 실행, 실제 작동

<br>  

### :pushpin: HTML 이란?

- 웹 페이지에서 다른 페이지로 이동할 수 있도록 하는 기능을 가진 문서를 만드는 언어.
- 웹 페이지를 위한 마크업 언어
- **하이퍼 링크** 시스템을 가지고 있다.
  - 하이퍼 링크 : 하이퍼텍스트 문서 내에서 **직접 모든 형식의 자료를 연결하고 가리킬 수 있는** 참조 고리

<br>

### :pushpin: JQuery란

- **정의**

  - 자바스크립트 라이브러리

  - 자바스크립트를 더 쉽게 사용하기 위해 만들어짐

  - HTML DOM을 손쉽게 조작할 수 있다.

  - **크로스 브라우징**을 지원한다.

    > **크로스브라우징 : 다른 기종 및 플랫폼에 따라 달리 구현되는 기술을 비슷하게 만듬과<br>동시에 어느 한쪽에 최적화되어 치우치지 않도록 공통요소를 사용하여 웹 페이지를<br>제작하는 기법**

  - **예시**

    ```javascript
    // ID를 호출하는 경우의 자바스크립트 코드
    document.getElementById('ID')
    
    // ID를 호출하는 경우의 JQuery 코드
    $('#ID')
    ```

<br>

### :pushpin: 웹 서버의 종류

1. **Apache**
2. **Nginx**
3. **llS**
4. **Tomcat(웹 애플리케이션 서버)**
5. **Weblogic**
6. **Web sphere**

<br> 

### :pushpin: JSP와 Servlet

- **JSP**
  - HTML에 자바 코드를 넣어 동적 페이지를 생성하는 웹 애플리케이션 도구다.
  - JSP 실행 시 서블릿으로 변환되며 웹 애플리케이션 서버에서 동작되며 필요한 기능을 수행
- **Servlet(Server + Let)**
  - 클라이언트 요청에 따라 결과를 반환하는 자바 프로그램
  - 서블릿 클래스의 구현 규칙을 지키고 있다.
  - MVC 패턴에서 컨트롤러 역할
  - 자바 스레드를 이용하여 동작한다.
  - UDP보다 처리속도 느림
- **차이점**
  - 결과적으로 같은 동작을 수행하지만, JSP는 HTML 내부에 작성되기 때문에 코드 작성이 편하고,<br> Servlet은 Java 코드 내부에 작성되기 때문에 가독성과 효율성이 떨어진다.
  - 서블릿은 자바 코드로 구현하고 컴파일 후 배포해야 한다.
  - 서블릿은 코드 수정시 재컴파일 후 배포해야 한다.

<br> 

### :pushpin: 클라이언트 사이드 & 서버 사이드

- **클라이언트 사이드**
  - 사용자 측에서 수행되는 애플리케이션(ex. Chrome, Whale..., Language ex. Javascript)
  - 무거운 처리는 클라이언트 측에서 수행하게 하여 서버에 부하를 최소화 시킴
  - 웹 브라우저는 인터프리터 컴파일 방식으로 서버에서 받아온 html, css, javascript를 클라이언트<br> 측에서 수행시킨다.
- **서버 사이드**
  - 서버 측에서 수행되는 애플리케이션(ex. 플라스크, node.js, jsp, php...)
  - 사용자의 요청에 따라 동적인 파일을 생성하고 전달하는 역할

<br> 

### :pushpin: Get과 Post 차이

- **Get과 Post Method란?**
  - HTTP라는 웹 데이터 송수신 프로토콜을 통해 서버가 클라이언트의 요청을 어떻게 처리해야<br> 할지에 대한 행위를 요청하는 메서드

- **Get method**
  - 서버로부터 정보를 조회하기 위해 설계된 메서드
  - 요청을 전송할 때 필요한 데이터를 **Request Body에 담지 않고**, **쿼리 스트링**을 통해 전송합니다.
    - **쿼리 스트링** : URL의 끝에 ? 기호 뒤로 키와 값 쌍으로 이루어진 요청 파라미터
  - **동일한 연산을 여러 번 수행하더라도 동일한 결과가 나타나야 한다는 성질이 있다.**
- **Post method**
  - 서버 리소스를 생성하거나 변경하기 위해 설계된 메서드
  - HTTP Request Body에 필요한 데이터를 담아서 전송한다.
  - Request Body에 데이터를 포함하기 때문에 길이에 제한 없이 데이터를 전송할 수 있다.
  - 패킷을 탈취했을 때 일반 HTTP 프로토콜로 전송했다면 Body의 내용을 확인할 수 있기 때문에<br> 중요한 데이터는 암호화 후 전송해야 한다.
  - **서버에게 동일한 요청을 여러 번 수행하더라도 응답은 항상 다를 수 있다.**

<br>

### :pushpin: 문서 객체 모델(DOM: Document Object Model) 이란?

- HTML, XML 문서의 프로그래밍 인터페이스이다.
- 문서의 구조화된 표현을 제공
- 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공하여 문서 구조, 스타일, 내용을 변경할 수 있도록<br> 도와준다.
- 웹 브라우저를 통해 내용이 해석된다.

<br> 

### :pushpin: 브라우저 객체 모델(BOM : Browser Object Model) 이란?

- 브라우저 전체를 객체로 관리하는 것
- DOM은 BOM의 일부분이다.



<br> 

***

<br> 

## :round_pushpin: Spring Framework

***

<br> 

### :pushpin: Annotation을 사용하는 이유

- Annotation 이란
  - 추가적인 정보를 제공해주는 **메타데이터**
    - **메타데이터** : 데이터를 위한 데이터
- Annotation 용도
  - 컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공한다.
  - 스프링 프레임워크가 IoC 컨테이너에 의해 미리 객체를 생성해놓고 사용해야 하는데,<br> 이때 코드를 자동으로 생성할 수 있도록 정보를 제공하기 위함
  - 즉, 빌드나 배치 시에 코드를 자동으로 생성할 수 있도록 정보를 제공

