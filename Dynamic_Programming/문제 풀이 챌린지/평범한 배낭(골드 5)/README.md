## Dynamic Programming 문제 풀이

***

<br> 

#### 평범한 배낭

- 1번째 물건부터 N번째 물건까지 고려했을 때, 무게 한도 1부터 K까지 담을 수 있는 최대 가치를 찾는 문제
- 최대 가치를 저장하기 위해서는 2차원 배열 DP를 사용해야 함
- dp[N]\[K]

예제 예시)

weight : 6, 4, 3, 5

value : 13, 8, 6, 12

원래는 인덱싱을 0부터 하지만, dp[N]\[K]를 출력했을 때 정답이 나오도록 하기 위해 1부터 인덱싱

무게 한도를 1부터 주어진 K 까지 순회하면서, 각 물건을 담았을 때 가질 수 있는 최대 가치를 저장해야 함



ex) 무게 한도가 1인 경우

1번째 물건 -> weight[1]은 6의 무게를 가지므로 담지 못 함 -> 따라서 dp[1]\[1]은 0이됨

2번째 물건 -> weight[2]는 4의 무게를 가지므로 담지 못 함 -> 따라서 dp[2]\[1]은 0이됨

.. 반복

ex) 무게 한도가 2인 경우

이때도 마찬가지로 아무것도 담지 못 하므로, 현재 무게에 대한 최대 가치를 이전에 담았던 무게의 최대 가치로 계속 업데이트 해줌

이전에 담았던 무게에 대한 최대 가치가 계속 없었으므로 0이 저장됨

ex) 무게 한도가 3인 경우

1번째 물건 -> weight[1]은 6의 무게를 가지므로 담지 못 함 -> 따라서 dp[1]\[3]은 0이됨

2번째 물건 -> 마찬가지로 못 담음 -> dp[2]\[3]은 0이됨

3번째 물건 -> weight[3]은 3의 무게를 가지므로 담을 수 있음 -> 근데 이전 무게에 대한 최대 가치가 0이므로, 3번째 물건에 대한 가치가 그대로 업데이트됨 -> 따라서 dp[3]\[3]은 6이됨

4번째 물건 -> weight[4]는 5의 무게를 가지므로 담을 수 없음 -> 근데 이전 무게에 대한 최대 가치가 6이니까, 4번째 물건에 대한 가치가 3번째 물건까지 담았을 때의 최대 가치로 업데이트됨 -> 따라서 dp[4]\[3]은 6이됨

..

이를 반복





```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int MAXN = 105;
const int MAXK = 100001;

int weight[MAXN];
int value[MAXN];

int dp[MAXN][MAXK];

// dp[i][k] : 1번째 물건부터 i번째 물건까지 고려했을 때, 담을 수 있는 가장 최대 가치
void solve(int N, int K)
{
    for(int i=1; i<=K; ++i) // 무게 한도
    {
        for(int j=1; j<=N; ++j) // 물건 순서
        {
            if(weight[j] > i)
            {
                dp[j][i] = dp[j-1][i]; // 이전 물건까지의 최대 가치를 저장함, 그래서 무게 한도가 똑같은 선에서 고려해야 함
            }
            else
            {
                // 현재 물건을 담고 남은 무게 한도가 가진 최대 가치를 더 담았을 때와 이전 물건까지의 최대 가치 중
                // 가장 큰 것을 담는다.
                dp[j][i] = max(dp[j-1][i-weight[j]] + value[j], dp[j-1][i]);
            }
        }
    }
}

int main()
{
    int N, K;

    cin>>N>>K;

    for(int i=1; i<=N; ++i)
    {
        cin>>weight[i]>>value[i];
    }

    solve(N, K);

    cout<<dp[N][K];
}
```





