## Dynamic Programming 문제 풀이
***

#### 카드 구매하기
  - 구매해야 하는 카드의 개수별로 가질 수 있는 최대 값을 계산해야 함
  - 구매할 카드의 개수가 1개일 경우,
    - 1가지 경우의 수 밖에 없음
  - 구매할 카드의 개수가 2개일 경우,
    - 1개의 카드팩을 사는 경우 + 1개의 카드백을 사는 경우
    - 2개의 카드팩을 하나만 사는 경우
  - 구매할 카드의 개수가 3개일 경우,
    - 1개의 카드팩을 사는 경우 + 1개의 카드팩을 사는 경우 + 1개의 카드팩을 사는 경우
    - 2개의 카드팩을 사는 경우 + 1개의 카드팩을 사는 경우
    - 3개의 카드팩을 하나만 사는 경우
  - 위를 일반화 시키면,
    - card[현재 사야하는 카드 개수] + (N - 1)개의 카드를 산다할 때 가질 수 있는 최대 값
    - card[현재 사야하는 카드 개수] + (N - 2)개의 카드를 산다할 때 가질 수 있는 최대 값
    - card[현재 사야하는 카드 개수] + (N - j)개의 카드를 산다할 때 가질 수 있는 최대 값이 됨

예시로 주어진 카드를, 각 인덱스에 넣는 작업 우선 수행
ex. 1, 5, 6, 7
card[1] = 1;  // 카드 1개를 살 때 지불해야 하는 금액 1원
card[2] = 5;  // 카드 2개를 살 때 지불해야 하는 금액 5원
card[3] = 6;  // ...
card[4] = 7;


카드를 1개 구매할 때,
 - card[1] = 1원 지불
위 케이스밖에 없음
***

카드 2개 구매할 때,
 - card[1] + card[1]
 - card[2]

위 두 개의 케이스 존재, 이는 아래와 같이 변형 가능
 - card[1] + 카드 1개를 구매할 때 최대 나올 수 있는 금액(동적 프로그래밍 배열에서 얻을 수 있음)
 - card[2] + 카드 0개를 구매할 때 최대 나올 수 있는 금액(동적 프로그래밍 배열에서 얻을 수 있음)

위는 또 아래와 같이 일반화 가능

card[1] + max[1]

card[2] + max[0]
***

카드 3개 구매할 때,
 - card[1] + card[1] + card[1]
 - card[2] + card[1]
 - card[3]

위는 아래와 같이 일반화 가능

card[1] + max[2]

card[2] + max[1]

card[3] + max[0]

즉, 현재 구하고자 하는 max[i]를 구하려면 (i : 1 ~ N), 현재 인덱스인 i 이전에 모든 카드를 조사하는 작업이 필요함.
***


따라서 현재 인덱스인 i개의 카드를 구매할 때 가질 수 있는 최대 금액을 계산하려면, 아래를 수행해야 함
> 오름차순으로 순회하는 i 인덱스 기준으로, N번째 인덱스부터 0번째 인덱스까지 가질 수 있는 
최대 금액을 더해줘야 함


```c++
#include <iostream>
#include <math.h>

using namespace std;

int card[1001];
int dp[1001];

void solve(int N)
{
    for(int i=2; i<=N; ++i) // i는 현재의 N이 되는것
    {
        for(int j=1; j <= i; ++j)
        {
            // if: i = 3
            // card[1] + dp[3-1] <=> dp[3]
            // card[2] + dp[3-2] <=> dp[3]
            // card[3] + dp[3-3] <=> dp[3]
            dp[i] = max(card[j] + dp[i-j], dp[i]);
        }
    }
}

int main()
{
    int N=0;
    cin>>N;

    for(int i=1; i<=N; ++i)
    {
        cin>>card[i];
    }

    dp[1] = card[1];

    solve(N);

    cout<<dp[N]<<'\n';
}
```