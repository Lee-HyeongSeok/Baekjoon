## Dynamic Programming 문제 풀이

***

<br> 

#### 퇴사

- 하향식으로 현재 일자 기준에서 작업이 가능한지 확인하면서 얻을 수 있는 최대 점수 계산
- 작업 진행은 가능하지만, 작업 일수에 비해 점수가 낮은 것들을 고려해야 함



```null
 	1일	2일	3일	4일	5일	6일	7일
Ti	3	 5	 1	   1	2	4	2
Pi	10	 20	 10	   20	15	40	200
```

7일부터 계산)

7일에 일정된 작업은 총 2일이 소요됨

-> 진행이 불가함

-> 진행이 불가한 일자에 대해서는, 이미 계산된 다음 점수를 그대로 가져감

dp[7] = dp[7 + 1]



6일 계산)

6일에 일정된 작업은 총 4일이 소요됨

-> 진행 불가

-> 진행이 불가한 일자는 마찬가지로, 이미 계산된 다음 점수를 그대로 가져감

dp[6] = dp[6 + 1]



5일 계산)

5일에 일정된 작업은 총 2일이 소요됨

-> 진행 가능, 7일부터 작업 시작 가능

따라서 5일에 작업을 진행했을 때

- 이미 계산된 다음 점수를 그대로 가져가는 것이 더 이득인지
- 현재 작업을 진행했을 때 받을 수 있는 점수와 작업을 마친 날짜에도 작업을 수행했을 때 받을 수 있는 점수의 합이 더 이득인지 판별

MAX (dp[5 + 1], dp[5 + 2] + pay[5])



4일 계산)

4일에 일정된 작업은 총 1일이 소요됨

-> 진행 가능, 5일부터 작업 시작 가능

따라서 4일에 작업 진행 시,

- 이미 계산된 다음 점수를 그대로 가져가는 것이 더 이득인지
- 현재 작업을 진행했을 때 받을 수 있는 점수와 작업을 마친 날짜에도 작업을 수행했을 때 받을 수 있는 점수의 합이 더 이득인지 판별

MAX (dp[4 + 1], dp[4 + 1] + pay[4])

이를 반복



```c++
#include <iostream>
#include <algorithm>

int dp[16];

int duration[16];
int pay[16];

using namespace std;

void solve(int N)
{
    int deadline;

    // i는 현재 일자
    for(int i=N; i>0; --i)
    {
        // duration[i]은 현재 일자에 작업 시작했을 때 소요되는 기간
        deadline = i + duration[i];

        if(deadline > N + 1)
        {
            dp[i] = dp[i + 1];
        }
        else
        {
            dp[i] = max(dp[i + 1], dp[deadline] + pay[i]);
        }
    }
}

int main()
{
    int N;
    cin >> N;
    
    for(int i=1; i<=N; ++i)
    {
        cin >> duration[i] >> pay[i];
    }

    solve(N);
    
    cout<<dp[1];
}
```





