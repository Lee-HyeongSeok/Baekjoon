## Dynamic Programming 문제 풀이

***

<br> 

#### LCS(Longest Common Subsequence) - 최장 공통 부분 수열

- 문자를 문자열마다 하나씩 비교하는데 시간이 많이 소요되니까 dp를 이용한 문제
- 하나의 문자를 각 부분 수열과 비교하면서 공통된 부분이 있으면 마킹
- 공통된 부분이 없으면, 이전 까지 비교했던 부분 수열들 중에 가장 긴 값으로 마킹

예제 예시)

1번 문자열 : ACAYKP

2번 문자열 : CAPCAK



1번 문자열의 각 문자를 기준으로, 2번 문자열의 부분 수열과 비교했을 때는 아래와 같다.

|      | C    | A    | P    | C    | A    | K    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| A    | 0    | 1    | 1    | 1    | 1    | 1    |
| C    |      |      |      |      |      |      |
| A    |      |      |      |      |      |      |
| Y    |      |      |      |      |      |      |
| K    |      |      |      |      |      |      |
| P    |      |      |      |      |      |      |

1번 문자열의 문자 A -> C 비교 : 일치하는거 없음 -> 따라서 0

1번 문자열의 문자 A -> CA 비교 : A 하나 일치 -> 따라서 1

1번 문자열의 문자 A -> CAP 비교 : A 하나 일치 -> 따라서 1

1번 문자열의 문자 A -> CAPC 비교 : A 하나 일치 -> 따라서 1

1번 문자열의 문자 A -> CAPCA 비교 : A 하나 일치 -> 따라서 1

..

이번에는 1번 문자열의 부분 수열인 AC를 기준으로 2번 문자열의 부분 수열과 비교한다.

|      | C    | A    | P    | C    | A    | K    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| A    | 0    | 1    | 1    | 1    | 1    | 1    |
| C    | 1    | 1    | 1    | 2    | 2    | 2    |
| A    |      |      |      |      |      |      |
| Y    |      |      |      |      |      |      |
| K    |      |      |      |      |      |      |
| P    |      |      |      |      |      |      |

1번 문자열의 부분 수열 AC -> C 비교 : 1개 일치 -> 따라서 1 기록

1번 문자열의 부분 수열 AC -> CA 비교 : A 또는 C 1개 일치 -> 따라서 1 기록

1번 문자열의 부분 수열 AC -> CAP 비교 : A 또는 C 1개 일치 -> 따라서 1 기록

1번 문자열의 부분 수열 AC -> CAPC 비교 : AC 2개 일치 -> 따라서 2 기록

1번 문자열의 부분 수열 AC -> CAPCA 비교 : AC 2개 일치 -> 따라서 2 기록

...



이를 반복하다보면 아래와 같은 규칙이 생성됨

현재 비교 대상의 문자가 각각 일치하면 -> 왼쪽 대각선 값 + 1

현재 비교 대상의 문자가 일치하지 않으면 -> 왼쪽 또는 위쪽에 존재하는 값 중에 가장 큰 값



* 이러한 규칙이 생성되는 이유는?
  * 현재 위치 기준으로 왼쪽 대각선에 대한 의미를 이해해야 함
    * 현재 위치가 CA고, 비교 대상이 ACA라고 한다면
    * 왼쪽 대각선에 있던 두 비교 대상들은 각각 C와 AC가됨
    * 그리고 현재 비교 대상의 문자 두 개가 일치한다는건, 이전에 비교했던 각 문자와 부분 수열이 가진 길이에 1개가 더해진다는 뜻
    * 따라서 왼쪽 대각선이 가진 값 + 1이, 현재 부분 수열이 추가되었을 때 가질 수 있는 최대 길이라는 뜻
  * 왼쪽 또는 위쪽에 존재하는 결과에 대한 의미를 이해해야 함
    * 현재 위치가 CA고, 비교 대상이 ACAY라고 한다면
    * 왼쪽은 CA <-> ACA의 비교, 위쪽은 C <-> ACAY의 비교가됨
    * 왼쪽의 경우에는, 이전까지 비교했던 부분 수열이 가진 가장 긴 값이 되고
    * 위쪽의 경우에는, 이전 문자로 현재 부분 수열을 비교했을 때 가질 수 있는 가장 긴 값이됨





```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int MAXN = 1001;

int dp[MAXN][MAXN];

void solve(std::string const& first, std::string const& second)
{
    for(int i=1; i<=first.size(); ++i)
    {
        for(int j=1; j<=second.size(); ++j)
        {
            if(first[i-1] == second[j-1])
            {
                dp[i][j] = dp[i-1][j-1] + 1;
            }
            else
            {
                dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
            }
        }
    }
}

int main()
{
    std::string first, second;
    cin>>first>>second;

    solve(first, second);

    cout<<dp[first.size()][second.size()];
}
```





